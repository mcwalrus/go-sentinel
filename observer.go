// Package sentinel provides reliability handling and observability monitoring for Go applications.
// It wraps task execution with Prometheus metrics, observing errors, panic occurrences, retries,
// and timeouts â€” making critical routines safe, measurable, and reliable.
package sentinel

import (
	"context"
	"errors"
	"sync"
	"time"

	"github.com/prometheus/client_golang/prometheus"
)

// ObserverConfig defines the configuration of an [Observer] instance,
// including Prometheus metrics naming and histogram bucket configuration.
type ObserverConfig struct {
	// Namespace is the Prometheus namespace for all metrics generated by this observer.
	// For example, "myapp" results in metrics like "myapp_sentinel_successes_total".
	// If empty, no namespace prefix is used.
	Namespace string

	// Subsystem is the Prometheus subsystem for all metrics generated by this observer.
	// For example, "workers" results in metrics like "workers_successes_total".
	// Defaults to "sentinel" if not specified.
	Subsystem string

	// Description is used in the help text for generated metrics to describe what type
	// of tasks are being observed. For example, "background processes" results in help
	// text like: "Number of successes from observed background processes".
	Description string

	// BucketUnits specifies the time unit interpretation for BucketDurations values.
	BucketUnits BucketUnit

	// BucketDurations defines the histogram buckets for task duration metrics.
	// Values are interpreted according to BucketUnits.
	BucketDurations []float64
}

// BucketUnit represents the unit of time for histogram bucket durations.
type BucketUnit int

const (
	// BucketUnitSeconds indicates that BucketDurations values are in seconds.
	BucketUnitSeconds BucketUnit = iota

	// BucketUnitMilliseconds indicates that BucketDurations values are in milliseconds.
	BucketUnitMilliseconds
)

func (c ObserverConfig) isZero() bool {
	if c.Namespace+c.Subsystem+c.Description == "" {
		if len(c.BucketDurations) == 0 {
			return true
		}
	}
	return false
}

// DefaultConfig returns a default ObserverConfig with defaults for most use cases.
// Consider updating the namespace, subsystem, and description to match your application.
func DefaultConfig() ObserverConfig {
	return ObserverConfig{
		Namespace:       "",
		Subsystem:       "sentinel",
		Description:     "tasks",
		BucketUnits:     BucketUnitSeconds,
		BucketDurations: []float64{0.01, 0.1, 1, 10, 100, 10_000},
	}
}

// Observer monitors and measures task executions, collecting Prometheus metrics
// for successes, failures, timeouts, panics, retries, and execution durations.
// It provides methods to execute tasks with various configuration options.
type Observer struct {
	cfg     ObserverConfig
	metrics *metrics
}

// NewObserver creates a new Observer instance with the specified configuration.
// The Observer will need to be registered with a Prometheus registry to expose metrics.
// Note the oberserver does not need to be registered with a Prometheus registry to work.
func NewObserver(cfg ObserverConfig) *Observer {
	if cfg.isZero() {
		cfg = DefaultConfig()
	} else {
		if cfg.Subsystem == "" {
			cfg.Subsystem = "sentinel"
		}
		if cfg.Description == "" {
			cfg.Description = "tasks"
		}
		if cfg.BucketUnits == BucketUnitMilliseconds {
			for i, v := range cfg.BucketDurations {
				cfg.BucketDurations[i] = v * 1000
			}
		}
	}
	return &Observer{
		cfg:     cfg,
		metrics: newMetrics(cfg),
	}
}

// Register registers all Observer metrics with the provided Prometheus registry.
// Use [MustRegister] if you want the program to panic on registration conflicts.
func (o *Observer) Register(registry *prometheus.Registry) {
	o.metrics.Register(registry)
}

// MustRegister registers all Observer metrics with the provided Prometheus registry.
// This method panics if any metric registration failures. Use [Register] if you prefer
// to handle registration errors gracefully.
func (o *Observer) MustRegister(registry *prometheus.Registry) {
	o.metrics.MustRegister(registry)
}

// Run executes a function with the specified task configuration and observes it's execution.
// All execution metrics (duration, success/failure, retries, etc) will be automatically recorded.
func (o *Observer) Run(cfg TaskConfig, fn func(ctx context.Context) error) error {
	task := &implTask{
		cfg: cfg,
		fn:  fn,
	}
	if !task.Config().Concurrent {
		return o.observe(task)
	} else {
		go o.observe(task)
	}
	return nil
}

// RunFunc executes a simple function once without a timeout and observes it's execution.
// All execution metrics (duration, success/failure, panic, etc) will be automatically recorded.
// If a [context.DeadlineExceeded] error is returned, it is recorded as a timeout occurrence.
// Panic recovery is ignored by default and needs to be manually handled.
func (o *Observer) RunFunc(fn func() error) error {
	task := &implTask{
		cfg: defaultTaskConfig(),
		fn: func(ctx context.Context) error {
			return fn() // ignore ctx
		},
	}
	if !task.Config().Concurrent {
		return o.observe(task)
	} else {
		go o.observe(task)
	}
	return nil
}

// RunTask executes a [Task] implementation and observes it's execution.
// The task.Config() method determines the execution behavior (timeout, retries, concurrency, etc).
// All execution metrics (duration, success/failure, retries, etc) will be automatically recorded.
func (o *Observer) RunTask(task Task) error {
	t := &implTask{
		cfg: task.Config(),
		fn:  task.Execute,
	}
	if !task.Config().Concurrent {
		return o.observe(t)
	} else {
		go o.observe(t)
	}
	return nil
}

// observe is the internal method that observes the task execution and handles retries.
func (o *Observer) observe(task *implTask) error {
	defer func() {
		if r := recover(); r != nil {
			o.metrics.Panics.Inc()
			if !task.Config().RecoverPanics {
				panic(r)
			}
		}
	}()

	start := time.Now()
	o.metrics.InFlight.Inc()
	observeOnce := sync.Once{}

	completeTask := func() {
		observeOnce.Do(func() {
			o.metrics.InFlight.Dec()
			o.metrics.ObservedRuntimes.Observe(
				time.Since(start).Seconds(),
			)
		})
	}
	defer completeTask()

	ctx := context.Background()
	if task.Config().Timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, task.Config().Timeout)
		defer cancel()
	}

	// Execute the task
	err := task.Execute(ctx)
	if err != nil {
		o.metrics.Errors.Inc()
		if errors.Is(err, context.DeadlineExceeded) {
			o.metrics.TimeoutErrors.Inc()
		}

		// Handle retries
		if task.Config().MaxRetries > 0 {
			o.metrics.Retries.Inc()
			cfg := task.Config()
			retryAttempt := cfg.MaxRetries - task.retryCount
			completeTask()

			if cfg.RetryCurcuitBreaker != nil {
				if cfg.RetryCurcuitBreaker(err) {
					return err
				}
			}

			if cfg.RetryStrategy != nil {
				wait := cfg.RetryStrategy(retryAttempt)
				if wait > 0 {
					time.Sleep(wait)
				}
			}

			retryTask := &implTask{
				fn:         task.Execute,
				cfg:        cfg,
				retryCount: task.retryCount + 1,
			}

			// Handles concurrency settings
			if !retryTask.Config().Concurrent {
				err2 := o.observe(retryTask)
				if err2 != nil {
					return errors.Join(err, err2)
				} else {
					// Successful on retry attempt
					return nil
				}
			} else {
				go o.observe(retryTask)
			}
		}
	} else {
		o.metrics.Successes.Inc()
	}

	return err
}
